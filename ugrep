#!/usr/bin/python3
# ugrep: find unicode characters based on their names.
# 	 Essentially grep for the Unicode table.

# See also b9's charname for the reverse operation.


# PREREQUISITES: You must have a copy of UnicodeData.txt installed.
# On Debian GNU/Linux, this can be done by `apt install unicode-data`.
# Or, you can download it by hand from the Unicode Consortium and
# place it in `~/.local/share/unicode/UnicodeData.txt`.

# Fun things to try:

# ugrep alchemical 
# ugrep ornament
# ugrep bullet
# ugrep '(vine|bud)'
# ugrep vai
# ugrep heavy
# ugrep drawing

# GPL ‚â•3 (see LICENSE file)
# B9 January 2018


from re import *
from sys import argv
from pprint import pprint 
from os.path import expanduser, expandvars, basename
from sys import stderr

debug=False

def eprint(*args, **kwargs):
    "Print to stderr"
    print(*args, file=stderr, **kwargs)

def debugprint(*args, **kwargs):
    "If debug var is True, print to stderr with progname prefix"
    if (debug):
        print(basename(argv[0]) + ": ", file=stderr, end='')
        print(*args, file=stderr, **kwargs)

def usage():
    print("""\
ugrep: find unicode characters based on their names
Usage: 
    ugrep <regex>

    Where regex is a regular expression or a plain string. 

    For example:

	$ ugrep heart
	‚òô	U+2619	REVERSED ROTATED FLORAL HEART BULLET
	‚ù£	U+2763	HEAVY HEART EXCLAMATION MARK ORNAMENT
	‚ù§	U+2764	HEAVY BLACK HEART
	[ ... examples truncated for brevity ... ]
	üòª	U+1F63B	SMILING CAT FACE WITH HEART-SHAPED EYES


	$ ugrep right.*gle
	$ ugrep right gle       	# Equivalent
	¬ª	U+00BB	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	‚Äô	U+2019	RIGHT SINGLE QUOTATION MARK
	‚àü	U+221F	RIGHT ANGLE
	‚äø	U+22BF	RIGHT TRIANGLE

        $ ugrep "\\bR\\b"         	# The letter R used as a word
        R	U+0052  LATIN CAPITAL LETTER R
        ≈ñ	U+0156  LATIN CAPITAL LETTER R WITH CEDILLA
        ‚Ñõ	U+211B  SCRIPT CAPITAL R (Script r)
        ‚Ñú	U+211C  BLACK-LETTER CAPITAL R (Black-letter r)
        ‚Ñù	U+211D  DOUBLE-STRUCK CAPITAL R (Double-struck r)
        
        $ ugrep backslash		# ugrep also searches in aliases
        \	U+005C	REVERSE SOLIDUS (backslash)

        $ ugrep ^x			# Regex ^ and $ work, mostly
        ‚äª	U+22BB	XOR
        ‚åß	U+2327	X IN A RECTANGLE BOX (clear key)

        $ ugrep .  |  less
        [ This would show you every single Unicode character! ]
"""
    )

# Main
if len(argv) == 1:
    usage()
    exit(1)


# Find the UnicodeData and load it up into ucd
ucdplaces=( "/usr/local/share/unicode/UnicodeData.txt",
            "/usr/share/unicode/UnicodeData.txt",
            "~/.local/share/unicode/UnicodeData.txt",
            "UnicodeData.txt" )
for f in ucdplaces:
    f=expanduser(expandvars(f)) 		# Python's open() is silly
    try:
        ucd=open(f).read()
        debugprint("Found data file at " + f)
    except:
        continue

# Sanity check: did we find the UnicodeData.txt file?
if ucd == None:
    eprint("""\
Could not find UnicodeData.txt in:

%s
On most GNU/Linux systems your package manager can install it easily.
For example:  apt install unicode-data.""" %
           ("".join(["    " + s + "\n" for s in ucdplaces])))
    exit(2)

if debug:
    debugprint("Number of Unicode chars: %d" % len(ucd.splitlines()))

# Format of ucd: each character is on a separate line.
# Each line is fifteen columns separated by semicolons.
# We only care about columns 1, 2, and 11
#      1: Code value
#      2: Character name
#     11: ISO 10646 comment field (usually an alias)
#
# For example:
#     002F;SOLIDUS;Po;0;CS;;;;;N;SLASH;;;;

# combine and quote the command line arguments so we can use them in
# verbose regex. Also, allow the user to use ^ and $, just like in awk
# to refer to the beginning and end of the field instead of line.
args=".*".join(argv[1:])          # search terms can have junk between
args=sub(r"(\s)", r"\\\1", args)  # quote whitespace for verbose regex
args=sub(r"^\^", r"(?<=;)", args) # ^ matches semicolon before field 
args=sub(r"\$$", r"(?=;)", args)  # $ matches semicolon after field 

# s is a search regex for field 2 (name) based on the command line arguments
s=r"""^
    (?P<hex>[^;]*);             # first field is hexadecimal codepoint
    (?P<name>[^;]*"""+args+"""[^;]*); # field 2 (charactername) matches?
    ([^;]*;){8}                 # skip next 8 fields
    (?P<alias>[^;]*)            # field 11 is comment/alias
    (;[^;]*){4}$                # line ends with four more fields
"""

# r is a search regex for field 11 (alias)
r=r"""^
    (?P<hextwo>[^;]*);            # first field is hexadecimal codepoint
    (?P<desctwo>[^;]*);           # second field is charactername
    ([^;]*;){8}                   # skip next 8 fields
    (?P<aliastwo>[^;]*("""+args+""")[^;]*) # field 11 (alias) matches?
    (;[^;]*){4}$                # line ends with four more fields
"""

# Search for either name or alias
s=s+"|"+r
s="(?mix)"+s                     # multiline, case insensitive, verbose

debugprint("Complete search regex is " + s)


if debug:
    m=search(s,ucd)
    if not m: debugprint("Definitely not in ucd")

for m in finditer(s, ucd):
    if m:
        g=m.groupdict()
        if g["hex"] == None: g["hex"]=g["hextwo"]
        if g["name"] == None: g["name"]=g["desctwo"]
        if g["alias"] == None: g["alias"]=g["aliastwo"]

        c=chr(int(g["hex"], 16))
        if not c.isprintable(): c="\ufffd" # U+FFFD = "Replacement Character"
        print(c, end='\t')
        print ("U+" + g["hex"], end='\t')
        print(g["name"], end='')
        if (len(g["alias"])):
            print (" (" + g["alias"].lower() + ")", end='')
        print()





# Implementation notes:

# This is a rewrite of b9's AWK ugrep in Python. While AWK makes a lot
# more sense for what this program does (comparing fields based on
# regexps), a rewrite was necessary because GNU awk, while plenty
# powerful, uses \y for word edges instead of \b and that was bugging
# me. Gawk does this for backwards compatibility with historic AWK,
# which is all well and good, but gawk has no way to disable it for
# new scripts.
#
# Switching to Python did have the benefit of allowing more powerful
# Perl-like regexes (not that anyone has requested that).
# 
# One downside is that I needed a huge hairy regex to simply search
# only in a certain field of each line. Maybe there's some Pythonic
# way to do it, but it's not obvious.
#
# Also, I took for granted that awk let me use ^ and $ to search for
# the beginning and ending of fields instead of lines. I tried to
# reimplement that in Python, but it's not quite right as it only
# checks the first and last character. For example, ugrep "^x" works,
# but ugrep "(^x)" does not.


# Note: I do not use Python's `unicodedata` module because it is
# insufficient. It allows one to search by character name only if the
# precise name: `unicodedata.lookup("ROTATED HEAVY BLACK HEART BULLET")`.

        
