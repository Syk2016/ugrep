#!/usr/bin/python3
# ugrep: find unicode characters based on their names or number.
# 	 Essentially grep for the Unicode table.

# PREREQUISITES: You must have a copy of UnicodeData.txt installed.
# On Debian GNU/Linux, this can be done by `apt install unicode-data`.
# Or, you can download it by hand from the Unicode Consortium and
# place it in `~/.local/share/unicode/UnicodeData.txt`.

# Fun things to try:

# ugrep alchemical 
# ugrep ornament
# ugrep bullet
# ugrep 'vine|bud'
# ugrep vai
# ugrep heavy
# ugrep drawing

# GPL ‚â•3 (see LICENSE file)
# B9 September 2018

from re import *
from sys import argv
from pprint import pprint 
from os.path import expanduser, expandvars, basename
from sys import stderr

debug=False

def eprint(*args, **kwargs):
    "Print to stderr"
    print(*args, file=stderr, **kwargs)

def err(*args, **kwargs):
    "Print to stderr with program name prefixed"
    eprint(basename(argv[0]) + ": ", end='')
    eprint(*args, **kwargs)

def debugprint(*args, **kwargs):
    "If debug var is True, print to stderr with progname prefix"
    if (debug):
        err(*args, **kwargs)

def usage():
    print("""\
ugrep: find unicode characters based on their names or codepoints
Usage: 
    ugrep [-w] <character> | <codepoint ...> | <character name>

    	-w:	matches only whole words, e.g., ugrep -w pi

    <character> is a single character, e.g.:  ugrep ‚òô
    <codepoint> is one or more hexadecimal unicode character numbers, 
		e.g.: ugrep U+23FB  or ugrep 23b{0..9}
    <character name> is a regular expression, see examples below.

    Character name examples:

	$ ugrep heart
	‚òô	U+2619	REVERSED ROTATED FLORAL HEART BULLET
	‚ù£	U+2763	HEAVY HEART EXCLAMATION MARK ORNAMENT
	‚ù§	U+2764	HEAVY BLACK HEART
	[ ... examples truncated for brevity ... ]
	üòª	U+1F63B	SMILING CAT FACE WITH HEART-SHAPED EYES


	$ ugrep right.*gle
	$ ugrep right gle       	# Equivalent
	¬ª	U+00BB	RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	‚Äô	U+2019	RIGHT SINGLE QUOTATION MARK
	‚àü	U+221F	RIGHT ANGLE
	‚äø	U+22BF	RIGHT TRIANGLE

        $ ugrep "\\bR\\b"         	# The letter R used as a word
        $ ugrep -w "R"	         	# Same as above, but simpler
        R	U+0052  LATIN CAPITAL LETTER R
        ≈ñ	U+0156  LATIN CAPITAL LETTER R WITH CEDILLA
        ‚Ñõ	U+211B  SCRIPT CAPITAL R (Script r)
        ‚Ñú	U+211C  BLACK-LETTER CAPITAL R (Black-letter r)
        ‚Ñù	U+211D  DOUBLE-STRUCK CAPITAL R (Double-struck r)
        
        $ ugrep backslash		# ugrep also searches in aliases
        \	U+005C	REVERSE SOLIDUS (backslash)

        $ ugrep ^x			# Regex ^ and $ work, mostly
        ‚äª	U+22BB	XOR
        ‚åß	U+2327	X IN A RECTANGLE BOX (clear key)

        $ ugrep .?  |  less
        [ This would show you every single Unicode character! ]
"""
    )

def isdifferent(a, b):
    """Given two strings A & B, determine if B is different enough from A
       that we don't need to print it as well. "Enough" means "adds
       significant new information". For example, the following would
       return False:
    
       "LATIN CAPITAL LETTER A WITH GRAVE", "LATIN CAPITAL LETTER A GRAVE"

       Note that order matters. For example,

       "BROKEN BAR", "BROKEN VERTICAL BAR" 	Should return True
       "BROKEN VERTICAL BAR", "BROKEN BAR" 	Should return False
    """
    a=a.upper()
    b=b.upper()

    if a == b:
        return False
    if a == b.replace(" DIGIT ", " "):
        return False
    if a == b.replace("FORMS ", "BOX DRAWINGS "):
        return False
    if a == b.replace("GRAPHIC ", "SYMBOL "):
        return False
    if a == b.replace("GLYPH ", "PRESENTATION FORM "):
        return False
    if a == b.replace("CENTER", "CENTRE"):
        return False
    if a == b.replace("CENTERED", "CENTRED"):
        return False
    if a == b.replace("SQUARED ", "SQUARE "):
        return False

    b=b.replace(" ", ".*")
    try:
        m=search(b, a)
        if m:
            return False
        else:
            return True
    except:
        # regex should never fail, but if it does, we don't care.
        return True


    # if a.replace("WARDS ", " ") == b:
    #     return False
    # if a.replace("S ", " ") == b:
    #     return False
    # if a.rstrip("S") == b:
    #     return False
    
    return True

def loaducd():
    "Find the UnicodeData.txt file and load it up into ucd global variable."

    global ucd
    ucdplaces=( "/usr/local/share/unicode/UnicodeData.txt",
                "/usr/share/unicode/UnicodeData.txt",
                "~/.local/share/unicode/UnicodeData.txt",
                "UnicodeData.txt" )
    for f in ucdplaces:
        f=expanduser(expandvars(f)) 		# Python's open() is silly
        try:
            ucd=open(f).read()
            debugprint("Found data file at " + f)
        except:
            continue

    # Sanity check: did we find the UnicodeData.txt file?
    if ucd == None:
        eprint("""\
    Could not find UnicodeData.txt in:

    %s
    On most GNU/Linux systems your package manager can install it easily.
    For example:  apt install unicode-data.""" %
               ("".join(["    " + s + "\n" for s in ucdplaces])))
        exit(2)

    if debug:
        debugprint("Number of Unicode chars: %d" % len(ucd.splitlines()))

    return ucd


def makeregexcharname():
    "Create a regular expression to search for a character name"

    # Format of ucd: each character is on a separate line.
    # Each line is fifteen columns separated by semicolons.
    # We only care about columns 1, 2, and 11
    #      1: Code value
    #      2: Character name
    #     11: ISO 10646 comment field (usually an alias)
    #
    # For example:
    #     002F;SOLIDUS;Po;0;CS;;;;;N;SLASH;;;;
    #
    # XXX Todo: maybe look up in table of confusable entities.

    # combine and quote the command line arguments so we can use them in
    # verbose regex. Also, allow the user to use ^ and $, just like in awk
    # to refer to the beginning and end of the field instead of line.
    global argv
    argv=["("+x+")" for x in argv]    # wrap in parens to fix | (alternation) 
    args=".*".join(argv[1:])          # search terms can have junk between
    args=sub(r"(\s)", r"\\\1", args)  # quote whitespace for verbose regex
    args=sub(r"^\^", r"(?<=;)", args) # ^ matches semicolon before field 
    args=sub(r"\$$", r"(?=;)", args)  # $ matches semicolon after field 

    # s is a search regex for field 2 (name) based on the command line arguments
    s=r"""^
        (?P<hex>[^;]*);             # first field is hexadecimal codepoint
        (?P<name>[^;]*"""+args+"""[^;]*); # field 2 (charactername) matches?
        ([^;]*;){8}                 # skip next 8 fields
        (?P<alias>[^;]*)            # field 11 is comment/alias
        (;[^;]*){4}$                # line ends with four more fields
    """

    # r is a search regex for field 11 (alias)
    r=r"""^
        (?P<hextwo>[^;]*);            # first field is hexadecimal codepoint
        (?P<desctwo>[^;]*);           # second field is charactername
        ([^;]*;){8}                   # skip next 8 fields
        (?P<aliastwo>[^;]*("""+args+""")[^;]*) # field 11 (alias) matches?
        (;[^;]*){4}$                  # line ends with four more fields
    """

    s=s+"|"+r                   # Search for either name or alias
    s="(?mix)"+s                # multiline, case insensitive, verbose

    debugprint("Complete search regex is " + s)

    return s

def makeregexcodepoint(cp):
    "Make a regular expression to search for a hexadecimal codepoint"

    # User specified a codepoint, e.g., "U+23fb" 

    # Normalize whatever they put in to "23FB"
    cp=cp.lstrip("Uu+0Xx").upper().zfill(4)

    # s is a search regex for field 1 (hexadecimal)
    s=r"""^
        (?P<hex>"""+cp+""");		#first field is hex codepoint
        (?P<name>[^;]*);		# second field is charactername
        ([^;]*;){8}			# skip next 8 fields
        (?P<alias>[^;]*)            	# field 11 is comment/alias
    """
    s="(?mix)"+s                     # multiline, case insensitive, verbose
    return(s)


# Main
def main():
    global argv

    if len(argv) == 1:
        usage()
        exit(1)

    if argv[1]=='-w':
        argv=argv[1:]
        for i in range(1,len(argv)):
            argv[i]="\\b"+argv[i]+"\\b"
        debugprint(argv)

    # Load the Unicode Data into the global ucd variable.
    loaducd()
    
    # Is it a single character? Then only show that one character.
    if len(argv[1])==1:
        s=makeregexcodepoint( hex(ord(argv[1])) )
        compileit(s)
        printmatches(s)
        exit(0)

    # Is first arg a hexadecimal number? E.g., 26A0, 0xdeadbeef, U+FACE
    # Then *also* look up that code point.
    if match(r"(?i)^(U\+?|0x)?[0-9A-F]+$", argv[1]):
        # Loop to allow people to do things like "ugrep 23b{0..9}"
        for arg in argv[1:]:
            if match(r"(?i)^(U\+?|0x)?[0-9A-F]+$", arg):
                s=makeregexcodepoint(arg)
                compileit(s)
                printmatches(s)
            else:
                break

    # Now, look up the entire argv[] as a character name or alias. 
    s=makeregexcharname()
    printmatches(s)


def compileit(s):
    global ucd, argv
    if debug:
        debugprint(s)
        m=search(s,ucd)
        if not m: debugprint("Definitely not in ucd")

    try:
        s=compile(s)
    except error as e:
        err("Error parsing regex: '%s'" % ".*".join(argv[1:]))
        err(e)
        exit(3)



def printmatches(s):
    for m in finditer(s, ucd):
        if m:
            g=m.groupdict()
            if g["hex"] == None: g["hex"]=g["hextwo"]
            if g["name"] == None: g["name"]=g["desctwo"]
            if g["alias"] == None: g["alias"]=g["aliastwo"]

            c=chr(int(g["hex"], 16))
            if not c.isprintable(): c="\ufffd" # U+FFFD=="Replacement Character"
            print(c, end='\t')
            print ("U+" + g["hex"], end='\t')
            print(g["name"], end='')
            if (len(g["alias"]) and isdifferent(g["name"], g["alias"])):
                print (" (" + g["alias"].lower() + ")", end='')
            print()


main()



# Implementation notes:

# This is a rewrite of b9's AWK ugrep in Python. While AWK makes a lot
# more sense for what this program does (comparing fields based on
# regexps), a rewrite was necessary because GNU awk, while plenty
# powerful, uses \y for word edges instead of \b and that was bugging
# me. Gawk does this for backwards compatibility with historic AWK,
# which is all well and good, but gawk has no way to disable it for
# new scripts.
#
# Switching to Python did have the benefit of allowing more powerful
# Perl-like regexes (not that anyone has requested that).
# 
# One downside is that I needed a huge hairy regex to simply search
# only in a certain field of each line. Maybe there's some Pythonic
# way to do it, but it's not obvious. Perhaps a 2D array?
#
# Also, I took for granted that awk let me use ^ and $ to search for
# the beginning and ending of fields instead of lines. I tried to
# reimplement that in Python, but it's not quite right as it only
# checks the first and last character. For example, ugrep "^x" works,
# but ugrep "(^x)" does not.


# Note: I do not use Python's `unicodedata` module because it is
# insufficient. It allows one to search by character name only if the
# precise name: `unicodedata.lookup("ROTATED HEAVY BLACK HEART BULLET")`.

