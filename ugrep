#!/usr/bin/python3
# ugrep: find unicode characters based on their names or number.
# 	 Essentially grep for the Unicode table.

# PREREQUISITE: 

# * You'll need a copy of UnicodeData.txt installed. On Debian
#   GNU/Linux, this can be done by `apt install unicode-data`. Or, you
#   can download it by hand from the Unicode Consortium and place it
#   in `~/.local/share/unicode/UnicodeData.txt`.

# ADDED FUNCTIONALITY: 

# * If you have FontConfig installed, then you can use -l to see which
#   fonts contain a certain character.
#
# * If you have ImageMagick installed and your terminal can display
#   sixels, then -l will also show a rendering of the character in
#   each font.


# Fun things to try:

# ugrep alchemical 
# ugrep ornament
# ugrep bullet
# ugrep 'vine|bud'
# ugrep vai
# ugrep heavy
# ugrep drawing
# ugrep 2300..ff

# GPL ‚â•3 (see LICENSE file)
# B9 September 2018 ‚Äì October 2021

debug=False

from re import *
from sys import argv, stderr
from os.path import expanduser, expandvars, basename
from os import isatty
from subprocess import getoutput, run
from posix import write
import termios
import argparse

def usage():
    print("""\
ugrep: find unicode characters based on their names or codepoints
Usage: 
    ugrep [-wlx] <character> | <codepoint ...> | <character name>
    ugrep -c <character string ...>

    	-w:	matches only whole words, e.g., ugrep -w pi
    	-c:	show each character in a string, e.g., ugrep -c "(Ôæü‚àÄÔæü)"
    	-l:	list installed fonts that include matching characters
	-x:	show example usage

           <character> A single character, e.g.:  ugrep ‚òô
           <codepoint> One or more hexadecimal unicode character numbers, 
		       optionally prefixed by "U+" or "0x".e.g.: ugrep U+1F639
    		       Ranges are allowed with two dots: ugrep 23b0..f
      <character name> A Unicode name (as a regex), e.g.: ugrep alchemical
    <character string> One or more characters. e.g.: ugrep -c "( Õ°¬∞ Õú ñ Õ°¬∞)"

    Try 'ugrep --examples' to see more examples of usage.
"""
    )

def examples():
    print("""\
# You can search by character name.
    $ ugrep heart
    ‚òô	U+2619	REVERSED ROTATED FLORAL HEART BULLET
    ‚ù£	U+2763	HEAVY HEART EXCLAMATION MARK ORNAMENT
    ‚ù§	U+2764	HEAVY BLACK HEART
    [ ... examples truncated for brevity ... ]
    üòª	U+1F63B	SMILING CAT FACE WITH HEART-SHAPED EYES

# Or, you can search by pasting in a specific character.
    $ ugrep ‚úø
    ‚úø       U+273F  BLACK FLORETTE

# Or, you can search by code point.
    $ ugrep 273a
    ‚ú∫       U+273A  SIXTEEN POINTED ASTERISK

# By default, words match anywhere.
    $ ugrep clos brac			# Equivalent to "clos.*brac"
    ]       U+005D  RIGHT SQUARE BRACKET (closing square bracket)
    }       U+007D  RIGHT CURLY BRACKET (closing curly bracket)
    „Äâ      U+3009  RIGHT ANGLE BRACKET (closing angle bracket)

# Use -w to match only whole words.
    $ ugrep -w "R"			# Equivalent to "\\bR\\b"
    R	U+0052  LATIN CAPITAL LETTER R
    ‚Ñõ	U+211B  SCRIPT CAPITAL R (Script r)
    ‚Ñú	U+211C  BLACK-LETTER CAPITAL R (Black-letter r)
    ‚Ñù	U+211D  DOUBLE-STRUCK CAPITAL R (Double-struck r)

# Use -c to display info for each character in a string.
    $ ugrep -c "·ïï( ·êõ )·ïó"
    ·ïï	U+1555	CANADIAN SYLLABICS FI
    (	U+0028	LEFT PARENTHESIS (opening parenthesis)
    ·êõ	U+141B	CANADIAN SYLLABICS NASKAPI WAA
    )	U+0029	RIGHT PARENTHESIS (closing parenthesis)
    ·ïó	U+1557	CANADIAN SYLLABICS FO

# ugrep finds aliases (in parens)
    $ ugrep backslash
    \	U+005C	REVERSE SOLIDUS (backslash)

# Regex ^ and $ work, mostly
    $ ugrep ^x				
    ‚äª	U+22BB	XOR
    ‚åß	U+2327	X IN A RECTANGLE BOX (clear key)

# Use -l to see which fonts are installed that can render a certain character
    $ ugrep -l math left tortoise
    ‚ü¨    U+27EC  MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET
                 Symbola 
                 Unifont 

# Show every single Unicode character. (Slow! Use 'fonttable' instead).
    $ ugrep 0..10FFFF  |  less"""
    )


# Main
def main():
    global argv, args

    # Load the Unicode Data into the global ucd variable.
    loaducd()
    
    if len(argv) == 1:
        usage()                 # ArgParse's usage is ugly, use our own.
        exit(1)

    if argv[1]=='-h' or argv[1]=='--help':
        usage()
        exit(0)

    if argv[1]=='-x' or argv[1]=='--examples' or argv[1]=='--example':
        examples()
        exit(0)

    parser = argparse.ArgumentParser(
        description='find Unicode characters by name, number, or example.')
    parser.add_argument(
        'characters', metavar='Character Name | Codepoint | Character', 
        nargs='+', type=str,
        help='which character to show specified by name, codepoint or literal example')
    parser.add_argument('-w', '--word-regexp', action="store_true",
        help='matches only whole words, e.g., ugrep -w pi')
    parser.add_argument('-c', '--char-by-char', action="store_true",
        help='show each character in a string, e.g., ugrep -c "(Ôæü‚àÄÔæü)"')
    parser.add_argument('-l', '--list-fonts', action="store_true",
        help='long listing, show fonts containing each character')
    parser.add_argument('-x', '--examples',  action="store_true",
        help='show example usage')

    args = parser.parse_args()

    # If -w, then wrap each argument with \b (regexp word breaks)
    if args.word_regexp:
        args.characters = [ "\\b"+s+"\\b" for s in args.characters ]

    # Is it -c followed by a string of characters?
    if args.char_by_char:
        # For each string s, look up each character in the string.
        for s in args.characters:
            for i in range(len(s)):
                for j in range(0,len(s[i])):
                    showonecharacter( hex(ord(s[i][j])) )
            if s is not args.characters[-1]:
                print("")       # Space between words, if multiple args 
        exit(0)

    # Is it a single character? Then only show that one character.
    if  len(args.characters)==1 and len(args.characters[0])==1:
        showonecharacter( hex(ord(args.characters[0][0])) )
        exit(0)

    # Do range expansion on argv. (e.g., 2301..f)
    args.characters = rangeexpansion(args.characters)

    # Is first arg a hexadecimal number? E.g., 26A0, 0xdeadbeef, U+FACE
    # Then *also* look up that code point.
    if match(r"(?i)^(U\+?|0x)?[0-9A-F]+$", args.characters[0]):
        # Loop to allow people to do things like "ugrep 23b{0..9}"
        for arg in args.characters:
            if match(r"(?i)^(U\+?|0x)?[0-9A-F]+$", arg):
                showonecharacter(arg)
            else:
                break

    # Now, look up the entire argv[] as a character name or alias. 
    s=makeregexcharname(args.characters)
    printmatches(s)


def showonecharacter(c):
    s=makeregexcodepoint(c)
    compileit(s)
    printmatches(s)
              
def compileit(s):
    "Compile the regular expresion in s, or die trying."
    global ucd, args

    if debug:
        debugprint(s)
        m=search(s,ucd)
        if not m: debugprint("Uncompiled, definitely not in ucd")

    try:
        s=compile(s)
    except error as e:
        err("Error parsing regex: '%s'" % ".*".join(args.characters))
        err(e)
        exit(3)


def isprint(c):
    # Given a category 'c', return True if it is printable.
    # We presume the only non-printable category is 'C' (control).
    # However, technically, much of category 'Z' (spaces) is non-printable.

    # Side note: Python is silly and regex clauses that match an empty
    # string are set to None instead of ''. That's why we doublecheck
    # that category is not None.
    return c and not c.startswith('C')

def iscombining(c):
    # Given a category 'c', return True if it is a combining character.
    # We presume all combining characters are in category 'M' and vice-versa.
    if debug:
        debugprint ("Category is <" + str(c) + ">")  

    return c and c.startswith('M')

def printmatches(s):
    category=""
    for m in finditer(s, ucd):
        if m:
            print("   ", end='') 	# Indent for MacOS
            g=m.groupdict()
            debugprint(g)
            if g["hex"] == None: g["hex"]=g["hextwo"]
            if g["name"] == None: g["name"]=g["desctwo"]
            category = g["category"] if g["category"] else g["categorytwo"]
            if g["alias"] == None: g["alias"]=g["aliastwo"]
            c=chr(int(g["hex"], 16))
            if not isprint(category): c="\ufffd" # "Replacement Character"
            if iscombining(category): print('\u25cc', end='') # "Dotted circle"
            print(c, end='\t')
            print ("U+" + g["hex"], end='\t')
            print(g["name"], end='')
            if (len(g["alias"]) and isdifferent(g["name"], g["alias"])):
                print (" (" + g["alias"].lower() + ")", end='')
            print("", flush=True)
            # If -l, show list of installed fonts which contain the glyph.
            if args.list_fonts:  show_fonts( g["hex"], category )


def show_fonts(x, category):
    """Given a hexadecimal string representing a Unicode code point, 
       list every installed font that defines a glyph at that code point."""
    
    try: fonts = getoutput("fc-list -f '%{family[0]}\t%{style[0]}\t%{file}\n' :charset=" + x + " | sort -u")
    except FileNotFoundError: print(""); return 	# No FontConfig
    except KeyboardInterrupt: exit(1) 			# Exit on ^C

    debugprint(fonts)
    
    oldfamily=""; oldstyle=""
    for f in fonts.splitlines():
        try: (family, style, filename) = f.split('\t')
        except: continue

        # Don't print same font twice (if installed in more than one
        # location or if multiple point sizes of a bitmap font).
        if (family == oldfamily and style == oldstyle): continue
        oldfamily=family; oldstyle=style
            
        # Don't print the style if it is just "Regular"
        if style == "Regular": style = ""

        print("\t\t%(family)s %(style)s\r" % locals(), end='')

        (width, height) = get_cell_size() # Character cell font size
        width=4*width                     # Three space indent
        background="Gray10"; foreground="Gray90"
        codepoint=chr(int(x,16))

        # If it's a combining character, add a dotted circle to combine with
        if iscombining(category): codepoint='\u25cc'+codepoint

        command=[ "convert",
                  "-size",
                  "%(width)sx%(height)s" % locals(),
                  "-background", "%(background)s" % locals(),
                  "-fill", "%(foreground)s" % locals(),
                  "-font", "%(filename)s" % locals(),
                  "-gravity", "east",
                  "label:" + codepoint,
                  "+dither",  
                  "-colors", "4",
                  "sixel:-" ]
        debugprint(command)

        try: output=run(command, capture_output=True)
        except FileNotFoundError: print(""); continue          # No ImageMagick
        except KeyboardInterrupt: exit(1)                      # Exit on ^C

        if output.returncode != 0:
            # Oops, font did not render.
            print("", flush=True)
            continue

        # Work around ImageMagick bug by deleting graphics newline (-) at end.
        output.stdout.replace(b'-\x1b\\', b'\x1b\\') 

        try: write(1, output.stdout) 		# Print raw bytes
        except KeyboardInterrupt:		# Catch ^C
            exit(1)                             # Sixels stopped by cleanup()


def get_cell_size():
    # Inquire from the terminal what its character cell size is.
    # Returns a tuple (width, height) in pixels. 

    # First, try termios. It's simple but doesn't work everywhere.
    import array, fcntl, termios
    buf = array.array('H', [0, 0, 0, 0])
    if isatty(1):
        fcntl.ioctl(1, termios.TIOCGWINSZ, buf)

    # Beware of the stupid output order: y x x y.   --Egmont Koblinger
    (rows, cols, x, y) = buf;

    # VT340 on serial line has x and y set to zero.
    if x==0 or y==0 or rows==0 or cols==0: return (10, 20)

    from math import floor

    debugprint("rows: %(rows)s\tcols: %(cols)s\tx: %(x)s\ty: %(y)s" % locals())
    debugprint("charcell w: %d\th: %d" % (floor(x/cols), floor(y/rows) ))
    return( floor(x/cols), floor(y/rows) )

def get_term_colors():
    # XXX not implemented yet
    # Inquire from the terminal what its character cell size is.
    # Returns a tuple (background, foreground) in pixels. 
    # fg = read -r -p $'\033]10;?\007' -d$'\007'
    # bg = read -r -p $'\033]11;?\007' -d$'\007'
    return ("gray10","gray90")

def isdifferent(a, b):
    """Given two strings A & B, determine if B is different enough from A
       that we don't need to print it as well. "Enough" means "adds
       significant new information". For example, the following would
       return False:
    
       "LATIN CAPITAL LETTER A WITH GRAVE", "LATIN CAPITAL LETTER A GRAVE"

       Note that order matters. For example,

       "BROKEN BAR", "BROKEN VERTICAL BAR" 	Should return True
       "BROKEN VERTICAL BAR", "BROKEN BAR" 	Should return False
    """
    a=a.upper()
    b=b.upper()

    if a == b:
        return False
    if a == b.replace(" DIGIT ", " "):
        return False
    if a == b.replace("FORMS ", "BOX DRAWINGS "):
        return False
    if a == b.replace("GRAPHIC ", "SYMBOL "):
        return False
    if a == b.replace("GLYPH ", "PRESENTATION FORM "):
        return False
    if a == b.replace("CENTER", "CENTRE"):
        return False
    if a == b.replace("CENTERED", "CENTRED"):
        return False
    if a == b.replace("SQUARED ", "SQUARE "):
        return False

    b=b.replace(" ", ".*")
    try:
        m=search(b, a)
        if m:
            return False
        else:
            return True
    except:
        # regex should never fail, but if it does, we don't care.
        return True


    # if a.replace("WARDS ", " ") == b:
    #     return False
    # if a.replace("S ", " ") == b:
    #     return False
    # if a.rstrip("S") == b:
    #     return False
    
    return True

def loaducd():
    "Find the UnicodeData.txt file and load it up into ucd global variable."

    global ucd
    ucd=None
    ucdplaces=( "/usr/local/share/unicode/UnicodeData.txt",
                "/usr/share/unicode/UnicodeData.txt",
                "~/.local/share/unicode/UnicodeData.txt",
                "UnicodeData.txt" )
    for f in ucdplaces:
        f=expanduser(expandvars(f)) 		# Python's open() is silly
        try:
            ucd=open(f).read()
            debugprint("Found data file at " + f)
        except:
            continue

    # Sanity check: did we find the UnicodeData.txt file?
    if ucd == None:
        eprint("""\
    Could not find UnicodeData.txt in:

%s
    On most GNU/Linux systems your package manager can install it easily.
    For example:  apt install unicode-data.

    Alternately, you can grab it via wget like so:

        mkdir -p ~/.local/share/unicode
	cd ~/.local/share/unicode
        wget ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
""" %
               ("".join(["    " + s + "\n" for s in ucdplaces])))
        exit(2)

    if debug:
        debugprint("Number of Unicode chars: %d" % len(ucd.splitlines()))

    return ucd


def makeregexcharname(words):
    "Create a regular expression to search for a character name"

    # Format of ucd: each character is on a separate line.
    # Each line is fifteen columns separated by semicolons.
    # We only care about columns 1, 2, 3 and 11
    #      1: Code value
    #      2: Character name
    #      3: General category
    #     11: ISO 10646 comment field (usually an alias)
    #
    # For example:
    #     002F;SOLIDUS;Po;0;CS;;;;;N;SLASH;;;;
    #
    # See Tech Report 44 for more details.
    #
    # XXX Todo: maybe look up in table of confusable entities.

    # combine and quote the command line arguments so we can use them in
    # verbose regex. Also, allow the user to use ^ and $, just like in awk
    # to refer to the beginning and end of the field instead of line.
    words=["("+x+")" for x in words]       # wrap in parens to fix alternation
    arghs=".*".join(words)                 # search terms can have junk between
    arghs=sub(r"(\s)", r"\\\1", arghs)     # quote whitespace for verbose regex
    arghs=sub(r"^\(\^", r"(?<=;)(", arghs) # ^ matches semicolon before field 
    arghs=sub(r"\$\)$", r"(?=;))", arghs)  # $ matches semicolon after field 

    # s is a search regex for field 2 (name) based on the command line arguments
    s=r"""^
        (?P<hex>[^;]*);             # first field is hexadecimal codepoint
        (?P<name>[^;]*"""+arghs+"""[^;]*); # field 2 (charactername) matches?
        (?P<category>[^;]*);        # third field is general category 
        ([^;]*;){7}                 # skip next 7 fields
        (?P<alias>[^;]*)            # field 11 is comment/alias
        (;[^;]*){4}$                # line ends with four more fields
    """

    # r is a search regex for field 11 (alias)
    r=r"""^
        (?P<hextwo>[^;]*);            # first field is hexadecimal codepoint
        (?P<desctwo>[^;]*);           # second field is charactername
        (?P<categorytwo>[^;]*);       # third field is general category 
        ([^;]*;){7}                   # skip next 7 fields
        (?P<aliastwo>[^;]*("""+arghs+""")[^;]*) # field 11 (alias) matches?
        (;[^;]*){4}$                  # line ends with four more fields
    """

    s=s+"|"+r                   # Search for either name or alias
    s="(?mix)"+s                # multiline, case insensitive, verbose

    debugprint("Complete search regex is " + s)

    return s

def makeregexcodepoint(cp):
    "Make a regular expression to search for a hexadecimal codepoint"

    # User specified a codepoint, e.g., "U+23fb" 

    # Normalize whatever they put in to "23FB"
    cp=cp.lstrip("Uu+0Xx").upper().zfill(4)

    # s is a search regex for field 1 (hexadecimal)
    s=r"""^
        (?P<hex>"""+cp+""");		#first field is hex codepoint
        (?P<name>[^;]*);		# second field is charactername
        (?P<category>[^;]*);		# third field is category
        ([^;]*;){7}			# skip next 7 fields
        (?P<alias>[^;]*)            	# field 11 is comment/alias
    """
    s="(?mix)"+s                     # multiline, case insensitive, verbose
    return(s)



def rangeexpansion(oldargv):
    """Look for ranges "a..z" in oldargv[] and expand by inserting new elements.
    The new argv is returned to the caller. 

    0..7 	-->	0 1 2 3 4 5 6 7
    abc0..7 	--> 	abc0 abc1 abc2 abc3 abc4 abc5 abc6 abc7
    23b8..f	-->	23b8 23b9 23ba 23bb 23bc 23bd 23be 23bf

    Notes:

    * Does check for and correctly ignores prefix of U+ or 0x.
    * Should check for invalid ranges and ignore them instead of barfing.

    Design notes:

    * Although similar to shell brace expansion, and ugrep even
      accepts braces, we never suggest to the user to try that. The
      problem is that shell brace expansion is decimal, whereas ugrep
      is working in hexadecimal.

      ugrep '23{01..10}'  -> sixteen characters, cumbersome.
      ugrep  23{01..10}   -> ten characters sometimes (e.g., using bash)
      ugrep 2301..10	  -> always sixteen characters (recommended).

    * In Bash, if start or end begin with a "0", then it zfills to
      that width. For this program, the 0 is optional as it always
      uses the largest width of the two ends E.g., 23{0..ff} -> 2300, 2301,...

      There is no confusion without braces: 230..ff -> 230, 231, ... 
    """

    s=r"""(?mix)
	  (?P<prefix>[^{]*)
	  {?                   # Literal open curly brace (optional)
	  (U\+?|0?x)?
    	  (?P<start>.*)
	  \.\.                 # Literal two periods. MANDATORY.
	  (U\+?|0?x)?
	  (?P<end>.*)
	  }?                   # Literal close curly brace (optional)
	  (?P<suffix>[^}]*)
    """
    s=compile(s)
    newargv=[]

    for arg in oldargv:
        m=search(s, arg)
        if not m:
            newargv.append(arg)
        else:
            debugprint("Doing range expansion on " + arg)
            g=m.groupdict()
            prefix=g["prefix"]
            start=g["start"].strip("{}") # Python doesn't do lazy regexps?
            end=g["end"].strip("{}")     # So, we kludge this way.

            if start == "":
                # They left off the braces: 2390..f instead of 239{0..f}
                start=prefix
                end=prefix[:-len(end)]+end
                prefix=""
                
            debugprint("Found range from " + start + " to " + end)
            z=max(len(start), len(end))
            start=int(start, 16)
            end=int(end, 16)

            for i in range(start, end+1):
                hexits=hex(i)[2:].zfill(z)
                newargv.append( prefix + hexits + g["suffix"] )
    return(newargv)


def eprint(*args, **kwargs):
    "Print to stderr"
    print(*args, file=stderr, **kwargs)

def err(*args, **kwargs):
    "Print to stderr with program name prefixed"
    eprint(basename(argv[0]) + ": ", end='')
    eprint(*args, **kwargs)

def debugprint(*args, **kwargs):
    "If debug var is True, print to stderr with progname prefix"
    if (debug):
        err(*args, **kwargs)

def cleanup():
    termios.tcdrain(2) 	# Wait for stderr to be printed
    if isatty(1):
        termios.tcflush(1, termios.TCOFLUSH) 	# Discard stdout
    print(chr(0x1b)+"\\", end='')               # String Terminator for sixels

import atexit
atexit.register(cleanup)


# VT340 is Latin-1 ISO8859-1 encoding.
# Python3 defaults to dying horribly on simple things like print('\u2020')
import sys
sys.stdout.reconfigure(errors='replace') 	# Print a ? instead of dying.


### Run the main routine
try:
    main()
except BrokenPipeError:
    # Ignore non-error errors. For example: 'ugrep -w pi | head'
    True
except KeyboardInterrupt:		# Catch ^C
    cleanup()

atexit.unregister(cleanup)      # Normal exit, no need to cleanup.


# Implementation notes:

# This is a rewrite of b9's AWK ugrep in Python. While AWK makes a lot
# more sense for what this program does (comparing fields based on
# regexps), a rewrite was necessary because GNU awk, while plenty
# powerful, uses \y for word edges instead of \b and that was bugging
# me. Gawk does this for backwards compatibility with historic AWK,
# which is all well and good, but gawk has no way to disable it for
# new scripts.
#
# Switching to Python did have the benefit of allowing more powerful
# Perl-like regexes (not that anyone has requested that).
# 
# One downside is that I needed a huge hairy regex to simply search
# only in a certain field of each line. Maybe there's some Pythonic
# way to do it, but it's not obvious. Perhaps a 2D array?
#
# Also, I took for granted that awk let me use ^ and $ to search for
# the beginning and ending of fields instead of lines. I tried to
# reimplement that in Python, but it's not quite right as it only
# checks the first and last character. For example, ugrep "^x" works,
# but ugrep "(^x)" does not.


# Note: I do not use Python's `unicodedata` module because it is
# insufficient. It allows one to search by character name only if the
# precise name: `unicodedata.lookup("ROTATED HEAVY BLACK HEART BULLET")`.

